diff --git a/resources/shaders/fragment.fs b/resources/shaders/fragment.fs
index bdda5e4..bbe460f 100644
--- a/resources/shaders/fragment.fs
+++ b/resources/shaders/fragment.fs
@@ -3,5 +3,6 @@ in vec2 uv;
 out vec4 color;
 uniform sampler2D textureSampler;
 void main () {
-    color = texture(textureSampler, uv);
+    //color = texture(textureSampler, uv);
+    color.xyz = vec3(1,0,0);
 }
\ No newline at end of file
diff --git a/resources/shaders/vertex.vs b/resources/shaders/vertex.vs
index 7a49efa..6a9881d 100644
--- a/resources/shaders/vertex.vs
+++ b/resources/shaders/vertex.vs
@@ -5,6 +5,7 @@ layout(location = 1) in vec2 uvOut;
 out vec2 uv;
 uniform mat4 camera;
 void main () {
-    gl_Position = camera * vec4(position, 0, 1);
+    //gl_Position = camera * vec4(position, 0, 1);
+    gl_Position = vec4(position, 0, 1);
     uv = uvOut;
 }
\ No newline at end of file
diff --git a/src/game/entity/component/component.cpp b/src/component/component.cpp
similarity index 55%
rename from src/game/entity/component/component.cpp
rename to src/component/component.cpp
index 74cd16a..fc70a80 100644
--- a/src/game/entity/component/component.cpp
+++ b/src/component/component.cpp
@@ -3,29 +3,30 @@
 
 #include "component.h"
 #include "logging/logging.h"
-#include "event/events.h"
-using namespace game;
+#include "event/events/entity_id_swap.h"
+using namespace component;
 
-game::ComponentManager::ComponentManager(id_type_t maxEntities, event::EventBus* bus) {
+component::ComponentManager::ComponentManager(int maxEntities, event::EventBus* bus) {
     this->maxEntities = fmin(maxEntities, MAX_COMPONENT_ENTITIES);
     this->numEntities = 0;
     this->bus = bus;
-    addComponent<AbstractEntity*>("entity_ptr");
+    addComponent<game::AbstractEntity*>("entity_ptr");
 }
-game::ComponentManager::~ComponentManager () {
+component::ComponentManager::~ComponentManager () {
     for (Component comp : components) {
         delete comp.data;
     }
 }
 
-id_type_t game::ComponentManager::getNumEntities () {
+id_type_t component::ComponentManager::getNumEntities () {
     return numEntities;
 }
-id_type_t game::ComponentManager::addEntity (AbstractEntity* entity) {
-    entity->setEntityId(numEntities);
+id_type_t component::ComponentManager::addEntity (game::AbstractEntity* entity) {
+    logging::logf(LEVEL_DEBUG, "Num entities: %d", numEntities);
+    getComponent<game::AbstractEntity*>(0)[numEntities] = entity;
     return numEntities++;
 }
-void game::ComponentManager::removeEntity (id_type_t entityId) {
+void component::ComponentManager::removeEntity (id_type_t entityId) {
     if (entityId >= numEntities) {
         logging::logf(LEVEL_ERROR, "Attempted to remove entity id %d, only %d entity components!", entityId, numEntities);
         return;
diff --git a/src/game/entity/component/component.h b/src/component/component.h
similarity index 52%
rename from src/game/entity/component/component.h
rename to src/component/component.h
index 648f768..e9be4f0 100644
--- a/src/game/entity/component/component.h
+++ b/src/component/component.h
@@ -2,7 +2,6 @@
 #include <string>
 #include <vector>
 
-#include "game/entity/entity.h"
 #include "event/event.h"
 #ifndef MAX_COMPONENT_ENTITIES
 #define MAX_COMPONENT_ENTITIES 256
@@ -10,44 +9,57 @@
 #ifndef COMPONENT_H
 #define COMPONENT_H
 #if MAX_COMPONENT_ENTITIES <= 256
-namespace game {
+namespace component {
     typedef unsigned char id_type_t;
 }
 #else
-namespace game {
+namespace component {
     typedef unsigned short id_type_t;
 }
 #endif
-unsigned char a;
+#ifndef ENTITY_H
 namespace game {
+    class AbstractEntity;
+}
+#endif
+namespace component {
     struct Component {
         void* data;
         size_t size;
+        size_t sizeElement;
     };
     class ComponentManager {
         private:
         std::unordered_map<std::string, int> componentIds;
         std::vector<Component> components;
         id_type_t numEntities;
-        id_type_t maxEntities;
+        int maxEntities;
         event::EventBus* bus;
         public:
-        ComponentManager(id_type_t maxEntities, event::EventBus* bus);
+        ComponentManager(int maxEntities, event::EventBus* bus);
         ~ComponentManager();
         template <typename T>
         void applyFunc (void func(T*, int, int), int compId) {
-            func((T*)components[compId].data, numEntities, 1);
-        };
+            func((T*)components[compId].data, numEntities, components[compId].sizeElement);
+        }
+        template <typename T, typename A>
+        void applyFunc (void func(T*, int, int, A), int compId, A extra) {
+            func((T*)components[compId].data, numEntities, components[compId].sizeElement, extra);
+        }
         template <typename T>
-        void applyFuncAsync (void func(T*, int, int), int compId, int numThreads) {
+        void applyFuncThreaded (void func(T*, int, int), int compId, int numThreads) {
             applyFunc(func, compId); // TODO: update
         }
-        template <typename T>
+        template <typename T, typename A>
+        void applyFuncThreaded (void func(T*, int, int , A), int compId, int numThreads, A extra) {
+            applyFunc(func, compId, extra); // TODO: same as above
+        }
+        template <typename T, int size = 1>
         int addComponent (std::string name) {
             if (componentIds.count(name) > 0) {
                 return -1;
             }
-            components.push_back({new T[maxEntities], sizeof(T)});
+            components.push_back({new T[maxEntities * size], sizeof(T) * size, size});
             componentIds[name] = components.size() - 1;
             return componentIds[name];
         }
@@ -59,13 +71,23 @@ namespace game {
         T* getComponent (std::string name) {
             return getComponent<T>(componentIds[name]);
         }
+        int getComponentId (std::string name) {
+            return componentIds[name];
+        }
         template <typename T>
         T getEntityData (int compId, int entityId) {
             // not the recommended way to access component data, use applyFunc where possible
-            return ((T*)components[compId].data)[entityId];
+            return ((T*)components[compId].data)[entityId * components[compId].sizeElement];
         };
+        template <typename T>
+        T* getEntityDataPtr (int compId, int entityId) {
+            return ((T*)components[compId].data) + entityId * components[compId].sizeElement;
+        }
+        int getElementSize (int compId) {
+            return components[compId].sizeElement;
+        }
         id_type_t getNumEntities ();
-        id_type_t addEntity (AbstractEntity* entity);
+        id_type_t addEntity (game::AbstractEntity* entity);
         void removeEntity (id_type_t entityId);
     };
 }
diff --git a/src/component/main_component.h b/src/component/main_component.h
new file mode 100644
index 0000000..9ecf57b
--- /dev/null
+++ b/src/component/main_component.h
@@ -0,0 +1,14 @@
+#ifndef MAIN_COMPONENT_H
+#define MAIN_COMPONENT_H
+namespace component {
+    struct EntityMainComponent {
+        float pos[2];
+        float vel[2];
+        float acc[2];
+        float constFriction;
+        float linFriction;
+        float vec1[2];
+        float vec2[2];
+    };
+}
+#endif
\ No newline at end of file
diff --git a/src/event/event.h b/src/event/event.h
index a725be5..dd4ed15 100644
--- a/src/event/event.h
+++ b/src/event/event.h
@@ -80,6 +80,7 @@ namespace event {
                     handler->handle(t);
                 }
             };
+            delete t;
         }
     };
    
diff --git a/src/event/events.h b/src/event/events.h
deleted file mode 100644
index 8d838f8..0000000
--- a/src/event/events.h
+++ /dev/null
@@ -1,46 +0,0 @@
-#include "event.h"
-#include "game/entity/entity.h"
-#include "game/game_object.h"
-#include "logging/logging.h"
-#ifndef EVENTS_H
-#define EVENTS_H
-namespace event {
-    static EventType* ENTITY_REGISTER_EVENT = nullptr;
-    static EventType* ENTITY_ID_SWAP_EVENT = nullptr;
-    class EntityRegisterEvent : public Event {
-        public:
-        game::GameObject* gameObject;
-        EntityRegisterEvent () {
-
-       }
-       EntityRegisterEvent (game::GameObject* gameObject) {
-           this->gameObject = gameObject;
-       }
-        virtual EventType* getEventType () {
-            if (ENTITY_REGISTER_EVENT == nullptr) {
-                ENTITY_REGISTER_EVENT = new EventType("entity_register", false, true);
-            }
-            return ENTITY_REGISTER_EVENT;
-        }
-    };
-    class EntityIdSwapEvent : public Event {
-        public:
-        int oldId;
-        int newId;
-        EntityIdSwapEvent () {
-            oldId = 0;
-            newId = 0;
-        }
-        EntityIdSwapEvent (int oldId, int newId) {
-            this->oldId = oldId;
-            this->newId = newId;
-        };
-        virtual EventType* getEventType () {
-            if (ENTITY_ID_SWAP_EVENT == nullptr) {
-                ENTITY_ID_SWAP_EVENT = new EventType("entity_id_swap", false, true);
-            }
-            return ENTITY_ID_SWAP_EVENT;
-        }
-    };
-}
-#endif
\ No newline at end of file
diff --git a/src/event/events/entity_creation.h b/src/event/events/entity_creation.h
new file mode 100644
index 0000000..c627b11
--- /dev/null
+++ b/src/event/events/entity_creation.h
@@ -0,0 +1,47 @@
+#include "event/event.h"
+#include "component/component.h"
+#include "graphics/graphics.h"
+#ifndef ENTITY_H
+namespace game {
+class AbstractEntity;
+};
+#endif
+#ifndef ENTITY_CREATION_H
+#define ENTITY_CREATION_H
+namespace event {
+    static EventType* ENTITY_CREATION_EVENT = nullptr;
+    class EntityCreationEvent : public Event {
+        public:
+        float x;
+        float y;
+        float size;
+        component::ComponentManager* compManager;
+        graphics::Graphics* graphics;
+        game::AbstractEntity* entity;
+        int entityId;
+        EntityCreationEvent () {
+            x = 0;
+            y = 0;
+            size = 0;
+            compManager = nullptr;
+            graphics = nullptr;
+            entityId = 0;
+        };
+        EntityCreationEvent (float x, float y, float size, component::ComponentManager* compManager, graphics::Graphics* graphics, game::AbstractEntity* entity, int entityId) {
+            this->x = x;
+            this->y = y;
+            this->size = size;
+            this->compManager = compManager;
+            this->graphics = graphics;
+            this->entity = entity;
+            this->entityId = entityId;
+        };
+        virtual EventType* getEventType () {
+            if (ENTITY_CREATION_EVENT == nullptr) {
+                ENTITY_CREATION_EVENT = new EventType("entity_creation", false, true);
+            }
+            return ENTITY_CREATION_EVENT;
+        }
+    };
+}
+#endif
\ No newline at end of file
diff --git a/src/event/events/entity_id_swap.h b/src/event/events/entity_id_swap.h
new file mode 100644
index 0000000..f0cf2fe
--- /dev/null
+++ b/src/event/events/entity_id_swap.h
@@ -0,0 +1,26 @@
+#include "event/event.h"
+#ifndef ENTITY_ID_SWAP_H
+#define ENTITY_ID_SWAP_H
+namespace event {
+    static EventType* ENTITY_ID_SWAP_EVENT = nullptr;
+    class EntityIdSwapEvent : public Event {
+        public:
+        int oldId;
+        int newId;
+        EntityIdSwapEvent () {
+            oldId = 0;
+            newId = 0;
+        }
+        EntityIdSwapEvent (int oldId, int newId) {
+            this->oldId = oldId;
+            this->newId = newId;
+        };
+        virtual EventType* getEventType () {
+            if (ENTITY_ID_SWAP_EVENT == nullptr) {
+                ENTITY_ID_SWAP_EVENT = new EventType("entity_id_swap", false, true);
+            }
+            return ENTITY_ID_SWAP_EVENT;
+        }
+    };
+}
+#endif
\ No newline at end of file
diff --git a/src/event/events/entity_register.h b/src/event/events/entity_register.h
new file mode 100644
index 0000000..2eb5fe7
--- /dev/null
+++ b/src/event/events/entity_register.h
@@ -0,0 +1,24 @@
+#include "event/event.h"
+#include "game/game_object.h"
+#ifndef ENTITY_REGISTER_H
+#define ENTITY_REGISTER_H
+namespace event {
+static EventType* ENTITY_REGISTER_EVENT = nullptr;
+class EntityRegisterEvent : public Event {
+        public:
+        game::GameObject* gameObject;
+        EntityRegisterEvent () {
+
+       }
+       EntityRegisterEvent (game::GameObject* gameObject) {
+           this->gameObject = gameObject;
+       }
+        virtual EventType* getEventType () {
+            if (ENTITY_REGISTER_EVENT == nullptr) {
+                ENTITY_REGISTER_EVENT = new EventType("entity_register", false, true);
+            }
+            return ENTITY_REGISTER_EVENT;
+        }
+    };
+}
+#endif
\ No newline at end of file
diff --git a/src/game/entity/entities.h b/src/game/entity/entities.h
index cf1667e..fe8c64d 100644
--- a/src/game/entity/entities.h
+++ b/src/game/entity/entities.h
@@ -1,5 +1,5 @@
 #include "entity.h"
-#include "event/events.h"
+#include "event/events/entity_register.h"
 #ifndef ENTITIES_H
 #define ENTITIES_H
 namespace game {
diff --git a/src/game/entity/entity.cpp b/src/game/entity/entity.cpp
index c609294..ce1770e 100644
--- a/src/game/entity/entity.cpp
+++ b/src/game/entity/entity.cpp
@@ -30,8 +30,11 @@ void game::AbstractEntity::setVelocity (float velX, float velY) {
 void game::AbstractEntity::updatePosition (float addedTime) {
     physicsBody->updatePosition(addedTime);
 }
+int game::AbstractEntity::getTextureId () {
+    return textureId;
+}
 // graphics code for base class
 
-void game::AbstractEntity::render (graphics::Graphics* graphics) {
-    graphics->drawTexSquare(x, y, scale, textureId);
-}
\ No newline at end of file
+/*void game::AbstractEntity::render (graphics::Graphics* graphics) {
+    graphics->drawTexSquare(*x, *y, scale, textureId);
+}*/
\ No newline at end of file
diff --git a/src/game/entity/entity.h b/src/game/entity/entity.h
index 9f69ba2..4829491 100644
--- a/src/game/entity/entity.h
+++ b/src/game/entity/entity.h
@@ -10,15 +10,15 @@ namespace game {
     class AbstractEntity {
         friend class GameObject;
         protected:
-        float x;
-        float y;
+        float* x;
+        float* y;
         float scale;
         physics::PhysicsBody* physicsBody;
         std::string name;
         int textureId;
         int entityId;
         public:
-        virtual AbstractEntity* createEntity (float x, float y) = 0;
+        virtual AbstractEntity* createEntity () = 0;
         virtual int getEntityId ();
         virtual std::string getEntityName ();
         
@@ -29,8 +29,8 @@ namespace game {
         virtual void setVelocity (float velX, float velY);
 
         virtual void setTextureIds (graphics::Graphics* graphics) = 0;
-        virtual void render (graphics::Graphics* graphics);
-
+        //virtual void render (graphics::Graphics* graphics);
+        virtual int getTextureId ();
         virtual void setEntityId (int entityId);
     };
 }
diff --git a/src/game/entity/entity_test.cpp b/src/game/entity/entity_test.cpp
index 736de5c..d1a6035 100644
--- a/src/game/entity/entity_test.cpp
+++ b/src/game/entity/entity_test.cpp
@@ -9,12 +9,15 @@ game::EntityTest::EntityTest() {
     name = "test_entity";
 }
 
-AbstractEntity* game::EntityTest::createEntity (float x, float y) {
+AbstractEntity* game::EntityTest::createEntity () {
     EntityTest* entity = new EntityTest ();
     entity->textureId = textureId;
     entity->scale = scale;
-    entity->physicsBody = new physics::PhysicsBody(&entity->x, &entity->y, 100, 0, 800);
+    entity->physicsBody = new physics::PhysicsBody(entity->x, entity->y, 100, 0, 800);
     entity->name = name;
+    if (entity == nullptr) {
+        logging::log(LEVEL_ERROR, "Null test entity!");
+    }
     return entity;
 }
 void game::EntityTest::setTextureIds (graphics::Graphics* graphics) {
diff --git a/src/game/entity/entity_test.h b/src/game/entity/entity_test.h
index 31ede83..d669f82 100644
--- a/src/game/entity/entity_test.h
+++ b/src/game/entity/entity_test.h
@@ -6,7 +6,7 @@ namespace game {
     class EntityTest : public AbstractEntity {
         public:
         EntityTest();
-        virtual AbstractEntity* createEntity(float x, float y);
+        virtual AbstractEntity* createEntity();
         virtual void setTextureIds (graphics::Graphics* atlas);
     };
 }
diff --git a/src/game/game_init.cpp b/src/game/game_init.cpp
index 47b6b5d..3637984 100644
--- a/src/game/game_init.cpp
+++ b/src/game/game_init.cpp
@@ -3,23 +3,38 @@
 
 #include "entity/entity_test.h"
 #include "entity/entities.h"
+#include "component/component.h"
+#include "component/main_component.h"
 #include "logging/logging.h"
+#include "graphics/graphics_handlers.h"
+#include "physics/physics_new.h"
 
 using namespace game;
 void addEventHandlers (GameObject* gameObject, graphics::Graphics* graphics);
+component::ComponentManager* getEntityComponentManager (event::EventBus* bus);
 GameObject* game::initGame (graphics::Graphics* graphics) {
     GameObject* gameObject = new GameObject();
+    gameObject->setGraphics(graphics);
     addEventHandlers(gameObject, graphics);
+    gameObject->setEntityComponentManager(getEntityComponentManager(gameObject->getEventBus()));
     logging::log(LEVEL_INFO, "Starting init of entities!");
     event::EntityRegisterEvent* entityEvent = new event::EntityRegisterEvent(gameObject);
     gameObject->getEventBus()->raiseEvent(entityEvent);
-    delete entityEvent;
-    
+    logging::log(LEVEL_DEBUG, "Finished entity init!");
     gameObject->setTextureIds(graphics);
+    logging::log(LEVEL_DEBUG, "Set texture ids!");
     return gameObject;
 }
 
 void addEventHandlers (GameObject* gameObject, graphics::Graphics* graphics) {
     gameObject->getEventBus()->subscribeHandler(game::addEntities);
+    gameObject->getEventBus()->subscribeHandler(graphics::onEntityCreation);
+    gameObject->getEventBus()->subscribeHandler(physics::onEntityCreation);
 }
 
+component::ComponentManager* getEntityComponentManager (event::EventBus* bus) {
+    component::ComponentManager* manager = new component::ComponentManager(256, bus);
+    manager->addComponent<component::EntityMainComponent>("main_component");
+    manager->addComponent<float, 12>("uv");
+    return manager;
+}
diff --git a/src/game/game_object.cpp b/src/game/game_object.cpp
index f20e031..95f3808 100644
--- a/src/game/game_object.cpp
+++ b/src/game/game_object.cpp
@@ -2,6 +2,8 @@
 #include "game_object.h"
 #include "graphics/graphics.h"
 #include "logging/logging.h"
+#include "physics/physics_new.h"
+#include "event/events/entity_creation.h"
 using namespace game;
 
 game::GameObject::~GameObject () {
@@ -33,14 +35,20 @@ AbstractEntity* game::GameObject::getEntity (std::string name) {
     }
 }
 AbstractEntity* game::GameObject::createNewEntityInstance (std::string name, float x, float y) {
+    // TODO: requires refactor
     if (entityRegistry.count(name) == 0) {
         logging::logf(LEVEL_WARNING, "Attempted creation of entity with name '%s' which doesn't exist!", name.c_str());
         return nullptr;
     } else {
-        auto entity = entityRegistry[name]->createEntity(x, y);
-        entity->setEntityId(currentEntityId);
-        entities[currentEntityId++] = entity;
-        logging::logf(LEVEL_DEBUG, "Created entity with name %s and id %d", name.c_str(), currentEntityId - 1);
+        auto entity = entityRegistry[name]->createEntity();
+        int entityId = entityComponentManager->addEntity(entity);
+        entity->setEntityId(entityId);
+        component::EntityMainComponent comp = entityComponentManager->getEntityData<component::EntityMainComponent>(entityComponentManager->getComponentId("main_component"), entityId);
+        entity->x = comp.pos;
+        entity->y = comp.pos + 1;
+        float* uvPtr = entityComponentManager->getEntityDataPtr<float>(entityComponentManager->getComponentId("uv"), entityId);
+        eventBus->raiseEvent(new event::EntityCreationEvent(x, y, entity->scale, entityComponentManager, graphics, entity, entityId));
+        logging::logf(LEVEL_DEBUG, "Created entity with name %s and id %d", name.c_str(), entityId);
         return entity;
     }
 }
@@ -95,9 +103,23 @@ void game::GameObject::updateEntityPositions (float deltaTime) {
     }
 }
 void game::GameObject::renderEntities (graphics::Graphics* graphics) {
-    for (auto const& it : entities) {
+    /*for (auto const& it : entities) {
         it.second->render(graphics);
-    }
+    }*/
+    // TODO: update to remove magic numbers (12 is uv components per sprite)
+    entityComponentManager->applyFunc<component::EntityMainComponent, graphics::Graphics*>([](component::EntityMainComponent* comp, int numSprites, int direction, graphics::Graphics* graphics){graphics->bufferEntityPositions(comp, numSprites, direction, graphics->getSpriteBuffer());}, 1, graphics);
+    entityComponentManager->applyFunc<float, graphics::Graphics*>([](float *uv, int numEntities, int direction, graphics::Graphics* graphics){
+        graphics::Buffer* buf = graphics->getSpriteBuffer(); 
+        for (int i = 0; i < numEntities; i++) {
+            float* uvPos = buf->getUvBufferPos();
+            for (int j = 0; j < 12; j++) {
+                *(uvPos++) = uv[i * 12 + j];
+                printf("%f ", uv[i * 12 + j]);
+                
+            }
+            printf("\n");
+        }
+    }, 2, graphics);
 }
 void game::GameObject::setTextureIds (graphics::Graphics* graphics) {
     for (auto const& it : entityRegistry) {
@@ -106,4 +128,13 @@ void game::GameObject::setTextureIds (graphics::Graphics* graphics) {
 }
 event::EventBus* game::GameObject::getEventBus () {
     return eventBus;
+}
+void game::GameObject::setEntityComponentManager (component::ComponentManager* manager) {
+    this->entityComponentManager = manager;
+}
+void game::GameObject::updateEntityPosition () {
+    entityComponentManager->applyFunc(physics::updatePhysics, 1); // TODO: remove hardcode (1 is index of main comp)
+}
+void game::GameObject::setGraphics (graphics::Graphics* graphics) {
+    this->graphics = graphics;
 }
\ No newline at end of file
diff --git a/src/game/game_object.h b/src/game/game_object.h
index fbbca13..ee5fa7d 100644
--- a/src/game/game_object.h
+++ b/src/game/game_object.h
@@ -5,6 +5,9 @@
 #include "graphics/textures/texture_atlas.h"
 #include "tile/tile.h"
 #include "event/event.h"
+#include "component/component.h"
+#include "component/main_component.h"
+#include "graphics/graphics.h"
 
 #ifndef GAME_OBJECT_H
 #define GAME_OBJECT_H
@@ -17,6 +20,8 @@ namespace game {
         std::vector<Tile*> tileRegistry;
         int currentEntityId = 0;
         event::EventBus* eventBus = new event::EventBus();
+        component::ComponentManager* entityComponentManager;
+        graphics::Graphics* graphics;
         public:
         ~GameObject();
 
@@ -33,10 +38,12 @@ namespace game {
         Tile* getTile (int tileId);
 
         void updateEntities (float deltaTime);
+        void updateEntityPosition ();
         void updateEntityPositions (float deltaTime);
         void setTextureIds (graphics::Graphics* atlas);
         void renderEntities (graphics::Graphics* graphics);
-        
+        void setEntityComponentManager (component::ComponentManager* manager);
+        void setGraphics (graphics::Graphics* graphics);
         event::EventBus* getEventBus();
     };
 }
diff --git a/src/game/gameloop.cpp b/src/game/gameloop.cpp
index 89621d5..6029195 100644
--- a/src/game/gameloop.cpp
+++ b/src/game/gameloop.cpp
@@ -9,21 +9,24 @@
 #include "key_defaults.h"
 
 #define TARGET_FPS 60
-
+#define PHYSICS_FPS 60
 using namespace game; 
 
 int game::gameloop (graphics::Graphics* graphics) {
     GameObject* gameObject = initGame(graphics);
     AbstractEntity* player = gameObject->createNewEntityInstance("test_entity", 0, 0);
+    logging::log(LEVEL_INFO, "Created player");
     KeyboardInput* keyInput = new KeyboardInput(graphics);
     setupMovementKeys(keyInput, &player);
     float deltaTime = 0.0f;
+    float deltaPhysicsFrame = 0.0f;
     float timeSinceFpsUpdate = 0.0f;
     int frames = 0;
     graphics->startTimer(TARGET_FPS);
     logging::log(LEVEL_DEBUG, "Starting loop");
     while (!graphics->shouldClose()) {
         deltaTime = graphics->getDeltaTime();
+        deltaPhysicsFrame += deltaTime;
         timeSinceFpsUpdate += deltaTime;
         if (timeSinceFpsUpdate >= 1.0f) {
             logging::logf(LEVEL_DEBUG, "Done %d frames in %f second(s), with an average fps of %f", frames, 
@@ -32,8 +35,12 @@ int game::gameloop (graphics::Graphics* graphics) {
             frames = 0;
         }
         keyInput->handleKeyPresses();
-        gameObject->updateEntities(deltaTime);
-        gameObject->updateEntityPositions(deltaTime);
+        while (deltaPhysicsFrame > 1.0f / PHYSICS_FPS) {
+            gameObject->updateEntityPosition();
+            deltaPhysicsFrame -= 1.0f / PHYSICS_FPS;
+        }
+        /*gameObject->updateEntities(deltaTime);
+        gameObject->updateEntityPositions(deltaTime);*/
         gameObject->renderEntities(graphics);
         graphics->render();
         graphics->pollEvents();
diff --git a/src/graphics/graphics.cpp b/src/graphics/graphics.cpp
index 8eba925..a2516a8 100644
--- a/src/graphics/graphics.cpp
+++ b/src/graphics/graphics.cpp
@@ -3,7 +3,7 @@
 #include <chrono>
 #include <thread>
 #include <algorithm>
-
+#include <math.h>
 #include "graphics.h"
 #include "graphics_headers.h"
 #include "camera.h"
@@ -57,7 +57,7 @@ void graphics::Graphics::renderStaticData () {
 void graphics::Graphics::pollEvents () {
     glfwPollEvents();
 }
-void graphics::Graphics::drawTexSquare (float x, float y, float scale, int textureId) {
+/*void graphics::Graphics::drawTexSquare (float x, float y, float scale, int textureId) {
     float* posData = new float[NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_POS_PER_VERTEX];
     float* posDataPtr = posData;
     for (int i = 0; i < NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE; i++) {
@@ -83,7 +83,7 @@ void graphics::Graphics::drawTexSquare (float x, float y, float scale, int textu
     Texture* tex = spriteAtlas->getTexture(textureId);
     spriteBuffer->pushBuffer(posData, tex->getTexUvs());
     delete[] posData;
-}
+}*/
 void graphics::Graphics::addShader (std::string name, ShaderProgram* shader) {
     shaderMap[name] = shader;
 }
@@ -271,7 +271,7 @@ void graphics::Buffer::reinitBuffer (unsigned int numSprites) {
     glEnableVertexAttribArray(1);
     glVertexAttribPointer(1, NUM_UV_PER_VERTEX, GL_FLOAT, GL_FALSE, 0, NULL);
 }
-void graphics::Buffer::pushBuffer (float* posData, float* uvData) {
+/*void graphics::Buffer::pushBuffer (float* posData, float* uvData) {
     if (++numSprites >= maxNumSprites) {
         reinitBuffer(maxNumSprites * 2); //TODO update to sensible values
     }
@@ -281,21 +281,33 @@ void graphics::Buffer::pushBuffer (float* posData, float* uvData) {
     memcpy(vertexUvCurrent, uvData, sizeUvData);
     vertexPosCurrent += NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_POS_PER_VERTEX;
     vertexUvCurrent += NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_UV_PER_VERTEX;
-}
+}*/
 void graphics::Buffer::flushBuffer (ShaderProgram* shader, Camera* camera, TextureAtlas* textureAtlas) {
+    float data[] = {0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f};
+    /*unsigned int numSprites = fmin(numSpritesVertex, numSpritesUv);
+    logging::logf(LEVEL_DEBUG, "flushing %d sprites (%d, %d)!", numSprites, numSpritesVertex, numSpritesUv);
     shader->useProgram();
-    shader->appplyUniform(camera->getUniformName(), camera->getCamMatrix());
+    //shader->appplyUniform(camera->getUniformName(), camera->getCamMatrix());
     textureAtlas->bindTextureAtlas();
     glBindBuffer(GL_ARRAY_BUFFER, posBufferId);
     glBufferSubData(GL_ARRAY_BUFFER, 0, numSprites * TRIANGLES_PER_SPRITE * 
-        NUM_TRIANGLE_VERTICES * NUM_POS_PER_VERTEX * sizeof(float), vertexPosData);
-
+        NUM_TRIANGLE_VERTICES * NUM_POS_PER_VERTEX * sizeof(float), data);
+    for (int i = 0; i < numSprites * TRIANGLES_PER_SPRITE * NUM_TRIANGLE_VERTICES * NUM_POS_PER_VERTEX; i++) {
+        printf("%f ", vertexPosData[i]);
+    }
     glBindBuffer(GL_ARRAY_BUFFER, uvBufferId);
     glBufferSubData(GL_ARRAY_BUFFER, 0, numSprites * TRIANGLES_PER_SPRITE * 
         NUM_TRIANGLE_VERTICES * NUM_UV_PER_VERTEX * sizeof(float), vertexUvData);
 
-    glDrawArrays(GL_TRIANGLES, 0, numSprites * TRIANGLES_PER_SPRITE * NUM_TRIANGLE_VERTICES);
-    numSprites = 0;
+    glDrawArrays(GL_TRIANGLES, 0, numSprites * TRIANGLES_PER_SPRITE * NUM_TRIANGLE_VERTICES);*/
+    glEnableVertexAttribArray(0); // TODO: update to better match layout for in position
+    glBindBuffer(GL_ARRAY_BUFFER, posBufferId);
+    glVertexAttribPointer(0, NUM_POS_PER_VERTEX, GL_FLOAT, GL_FALSE, 0, NULL);
+    glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+    glDisableVertexAttribArray(0);
+    numSpritesUv = 0;
+    numSpritesVertex = 0;
     vertexPosCurrent = vertexPosData;
     vertexUvCurrent = vertexUvData;
 }
@@ -306,4 +318,44 @@ graphics::Buffer::~Buffer () {
     if (vertexUvData != NULL) {
         free(vertexPosData);
     }
+}
+
+void Graphics::bufferEntityPositions (component::EntityMainComponent* comp, int numEntities, int direction, Buffer* buffer) {
+    for (int i = 0; i < numEntities; i++) {
+        auto ptr = buffer->getVertexBufferPos();
+        float vertices[4][2];
+        vertices[0][0] = comp->pos[0];
+        vertices[0][1] = comp->pos[1];
+        vertices[1][0] = vertices[0][0] + comp->vec1[0];
+        vertices[1][1] = vertices[0][1] + comp->vec1[1];
+        vertices[2][0] = vertices[0][0] + comp->vec2[0];
+        vertices[2][1] = vertices[0][1] + comp->vec2[1];
+        vertices[3][0] = vertices[0][0] + comp->vec1[0] + comp->vec2[0];
+        vertices[3][1] = vertices[0][1] + comp->vec1[1] + comp->vec2[1];
+        for (int j = 0; j < NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_POS_PER_VERTEX; j++) {
+            int correctedVertex = j % NUM_TRIANGLE_VERTICES + j / NUM_TRIANGLE_VERTICES;
+            ptr[2 * j] = vertices[correctedVertex][0];
+            ptr[2 * j + 1] = vertices[correctedVertex][1];
+            printf("(%f,%f) ", vertices[correctedVertex][0], vertices[correctedVertex][1]);
+        }
+        printf("\n");
+    }
+}
+float* Buffer::getVertexBufferPos () {
+    float* original = vertexPosCurrent;
+    vertexPosCurrent += NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_POS_PER_VERTEX;
+    numSpritesVertex++;
+    return original;
+}
+float* Buffer::getUvBufferPos () {
+    float* original = vertexUvCurrent;
+    vertexUvCurrent += NUM_TRIANGLE_VERTICES * TRIANGLES_PER_SPRITE * NUM_UV_PER_VERTEX;
+    numSpritesUv++;
+    return original;
+}
+Buffer* Graphics::getSpriteBuffer () {
+    return spriteBuffer;
+}
+TextureAtlas* Graphics::getTextureAtlas () {
+    return spriteAtlas;
 }
\ No newline at end of file
diff --git a/src/graphics/graphics.h b/src/graphics/graphics.h
index 50623d4..ad016c3 100644
--- a/src/graphics/graphics.h
+++ b/src/graphics/graphics.h
@@ -3,6 +3,7 @@
 #include "camera.h"
 #include "textures/texture.h"
 #include "textures/texture_atlas.h"
+#include "component/main_component.h"
 #include <stdlib.h>
 #include <vector>
 #include <unordered_map>
@@ -28,11 +29,16 @@
                 GLuint vaoId;
                 size_t posBufferSize;
                 size_t uvBufferSize;
-                unsigned int numSprites;
+                unsigned int numSpritesVertex;
+                unsigned int numSpritesUv;
                 unsigned int maxNumSprites;
             public:
                 void initBuffer (unsigned int numSprites);
                 void reinitBuffer (unsigned int numSprites);
+                float* getVertexBufferPos ();
+                float* getUvBufferPos();
+                void incrementVertexPtr (int amount);
+                void incrementUvPtr (int amount); 
                 void pushBuffer (float* posData, float* uvData);
                 void flushBuffer (ShaderProgram* shader, Camera* camera, TextureAtlas* textureAtlas);
                 ~Buffer();
@@ -75,10 +81,13 @@
                 void initBuffer (unsigned int numSprites);
                 void startTimer (int fps);
                 float getDeltaTime ();
+                Buffer* getSpriteBuffer ();
                 StaticData* loadStaticData (float* vertexArray, float* uvArray, int numVertices, int sizeVertex, int sizeUv, 
                     std::string shader);
                 void unloadStaticData (StaticData* data);
                 void setupErrorHandling ();
+                void bufferEntityPositions (component::EntityMainComponent* comp, int numEntities, int direction, Buffer* buffer);
+                TextureAtlas* getTextureAtlas ();
                 friend class game::KeyboardInput;
         };
     }
diff --git a/src/graphics/graphics_handlers.cpp b/src/graphics/graphics_handlers.cpp
new file mode 100644
index 0000000..a3cb1cb
--- /dev/null
+++ b/src/graphics/graphics_handlers.cpp
@@ -0,0 +1,18 @@
+#include "graphics_handlers.h"
+#include "event/events/entity_creation.h"
+#include "game/entity/entity.h"
+using namespace graphics;
+
+void graphics::onEntityCreation (event::EntityCreationEvent* event) {
+    int texId = event->entity->getTextureId();
+    unsigned int id = event->entityId;
+    logging::logf(LEVEL_DEBUG, "Beginning copying of uvs at id %d! graphics == null? %d", texId, event->graphics == nullptr);
+    float* pointer = event->compManager->getEntityDataPtr<float>(2, id);
+    logging::log(LEVEL_DEBUG, "Here!");
+    TextureAtlas* atlas = event->graphics->getTextureAtlas();
+    logging::log(LEVEL_DEBUG, "Here!");
+    Texture* tex = atlas->getTexture(texId);
+    logging::log(LEVEL_DEBUG, "Here!");
+    memcpy(pointer, tex->getTexUvs(), 12 * sizeof(float));
+    logging::log(LEVEL_DEBUG, "Ending copying of uvs!");
+}
\ No newline at end of file
diff --git a/src/graphics/graphics_handlers.h b/src/graphics/graphics_handlers.h
new file mode 100644
index 0000000..ecaa946
--- /dev/null
+++ b/src/graphics/graphics_handlers.h
@@ -0,0 +1,7 @@
+#include "event/events/entity_creation.h"
+#ifndef GRAPHICS_HANDLERS_H
+#define GRAPHICS_HANDLERS_H
+namespace graphics {
+void onEntityCreation (event::EntityCreationEvent* event);
+}
+#endif
\ No newline at end of file
diff --git a/src/graphics/graphics_init.cpp b/src/graphics/graphics_init.cpp
index 7316d2f..44ff760 100644
--- a/src/graphics/graphics_init.cpp
+++ b/src/graphics/graphics_init.cpp
@@ -7,6 +7,7 @@
 #include "logging/logging.h"
 #include "shaders/shaders.h"
 #include "textures/image.h"
+#include "graphics/graphics_handlers.h"
 
 using namespace graphics;
 
diff --git a/src/physics/physics_new.cpp b/src/physics/physics_new.cpp
new file mode 100644
index 0000000..b875092
--- /dev/null
+++ b/src/physics/physics_new.cpp
@@ -0,0 +1,32 @@
+#include "physics_new.h"
+#include "math.h"
+
+using namespace physics;
+void physics::updatePhysics (component::EntityMainComponent* comp, int numEntities, int direction) {
+    // TODO: consider writing fully in assembly
+    for (int i = 0; i < numEntities; i ++) {
+        int isPosXVel = comp->vel[0] > 0;
+        int isPosYVel = comp->vel[1] > 0;
+
+        comp->vel[0] -= (ceil((float)comp->vel[0] * comp->linFriction) + comp->constFriction) * (isPosXVel * 2 - 1);
+        comp->vel[1] -= (ceil((float)comp->vel[1] * comp->linFriction) + comp->constFriction) * (isPosYVel * 2 - 1);
+
+        comp->vel[0] *= (comp->vel[0] > 0 && isPosXVel);
+        comp->vel[1] *= (comp->vel[1] > 0 && isPosYVel);
+
+        comp->vel[0] += comp->acc[0];
+        comp->vel[1] += comp->acc[1];
+
+        comp->pos[0] += comp->vel[0];
+        comp->pos[1] += comp->vel[1];
+        comp += direction;
+    }
+}
+void physics::onEntityCreation (event::EntityCreationEvent* event) {
+    logging::log(LEVEL_DEBUG, "About to get main component!");
+    component::EntityMainComponent* comp = event->compManager->getEntityDataPtr<component::EntityMainComponent>(1, event->entityId);
+    comp->pos[0] = event->x;
+    comp->pos[1] = event->y;
+    comp->vec1[0] = event->size;
+    comp->vec2[1] = event->size;
+}
\ No newline at end of file
diff --git a/src/physics/physics_new.h b/src/physics/physics_new.h
new file mode 100644
index 0000000..0905084
--- /dev/null
+++ b/src/physics/physics_new.h
@@ -0,0 +1,10 @@
+#include "component/component.h"
+#include "component/main_component.h"
+#include "event/events/entity_creation.h"
+#ifndef PHYSICS_NEW_H
+#define PHYSICS_HEW_H
+namespace physics {
+    void updatePhysics (component::EntityMainComponent* comp, int numEntities, int direction);
+    void onEntityCreation (event::EntityCreationEvent* event);
+}
+#endif
\ No newline at end of file
